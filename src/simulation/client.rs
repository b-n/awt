use super::{Attribute, ClientProfile};
use std::cmp::Ordering;
use std::sync::{atomic, atomic::AtomicUsize, Arc};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Status {
    Pending,
    Enqueued,
    Abandoned,
    Answered,
}

impl Default for Status {
    fn default() -> Self {
        Self::Pending
    }
}

static ID_COUNTER: AtomicUsize = AtomicUsize::new(0);

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Client {
    id: usize,
    required_attributes: Vec<Attribute>,
    start: usize,
    abandon_tick: usize,
    established: Option<usize>,
    end: Option<usize>,
    status: Status,
}

impl Default for Client {
    fn default() -> Self {
        Self {
            id: ID_COUNTER.fetch_add(1, atomic::Ordering::SeqCst),
            required_attributes: vec![],
            start: 0,
            abandon_tick: 0,
            established: None,
            end: None,
            status: Status::default(),
        }
    }
}

impl Ord for Client {
    fn cmp(&self, other: &Self) -> Ordering {
        self.start.cmp(&other.start)
    }
}

impl PartialOrd for Client {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl From<&Arc<ClientProfile>> for Client {
    fn from(client_profile: &Arc<ClientProfile>) -> Self {
        Self {
            required_attributes: client_profile.required_attributes.clone(),
            abandon_tick: client_profile.base_abandon_tick,
            ..Self::default()
        }
    }
}

impl Client {
    /// Returns the `id` of this client.
    ///
    /// The `id` is autogenerated when the client is constructed, and is gauranteed to be unique
    /// for all `Client`s in this thread.
    #[inline]
    pub fn id(&self) -> usize {
        self.id
    }

    /// Set the start tick when the client should begin queuing.
    ///
    /// When the client is constructed with an `abandon_tick`, which is moved relative to
    /// `self.start` at the moment the `start` is set.
    pub fn set_start(&mut self, tick: usize) -> usize {
        self.start = tick;
        self.abandon_tick += self.start;
        self.abandon_tick
    }

    /// Returns the `start` tick of this client (when it should be enqueud).
    #[inline]
    pub fn start(&self) -> usize {
        self.start
    }

    #[allow(dead_code)]
    pub fn add_required_attribute(&mut self, attr: &Attribute) {
        self.required_attributes.push(attr.clone());
    }

    #[inline]
    pub fn required_attributes(&self) -> &Vec<Attribute> {
        &self.required_attributes
    }

    /// Returns the `Status` of this `Client`.
    #[inline]
    pub fn status(&self) -> &Status {
        &self.status
    }

    pub fn enqueue(&mut self, tick: usize) {
        assert!(
            tick == self.start,
            "[CLIENT] {}. Unexpected Enqueue time. Expected: {}, Tried at: {}",
            self.id,
            self.start,
            tick
        );
        self.status = Status::Enqueued;
        println!("[CLIENT] {} enqueued at {}", self.id, tick);
    }

    // Returns whether the Client is continuing to wait
    pub fn tick_wait(&mut self, tick: usize) -> bool {
        if Status::Enqueued != self.status {
            return false;
        }

        assert!(
            tick >= self.start,
            "Cannot tick in the past. started: {}, current: {}",
            self.start,
            tick
        );

        if self.abandon_tick <= tick {
            println!("[CLIENT] {} abandoned at {}", self.id, tick);
            self.status = Status::Abandoned;
            self.end = Some(tick);
            false
        } else {
            true
        }
    }

    pub fn handle(&mut self, tick: usize, handling_time: usize) -> usize {
        assert_eq!(
            Status::Enqueued,
            self.status,
            "Cannot tick Client when not enqueued"
        );

        assert!(
            tick >= self.start,
            "Cannot tick in the past. started: {}, current: {}",
            self.start,
            tick
        );

        println!("[CLIENT] {} handled at {}", self.id, tick);

        self.established = Some(tick);
        let end = tick + handling_time;
        self.end = Some(end);
        self.status = Status::Answered;

        end
    }

    #[allow(dead_code)]
    pub fn wait_time(self) -> Option<usize> {
        self.established.or(self.end).map(|t| t - self.start)
    }

    #[allow(dead_code)]
    pub fn handle_time(self) -> Option<usize> {
        if Status::Answered == self.status {
            let established = self
                .established
                .expect("Client should have an established time if answered");
            self.end.map(|t| t - established)
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn enqueued_client(start: usize) -> (Client, usize) {
        let mut client = Client {
            abandon_tick: 1000,
            ..Default::default()
        };
        let abandon_tick = client.set_start(start);
        client.enqueue(start);
        (client, abandon_tick)
    }

    #[test]
    fn default_status_is_pending() {
        let client = Client::default();
        assert_eq!(&Status::Pending, client.status());
    }

    #[test]
    fn abandons_past_abandonment_tick() {
        let (mut client, abandon_tick) = enqueued_client(100);

        client.tick_wait(abandon_tick - 1);
        assert_eq!(&Status::Enqueued, client.status());
        assert!(!client.tick_wait(abandon_tick));
        assert_eq!(&Status::Abandoned, client.status());
    }

    #[test]
    fn only_ticks_when_unanswered() {
        let (mut client, abandon_tick) = enqueued_client(100);

        client.tick_wait(abandon_tick);

        assert!(!client.tick_wait(abandon_tick + 1));
    }

    #[should_panic]
    #[test]
    fn panics_ticking_in_past() {
        let (mut client, _) = enqueued_client(100);

        client.tick_wait(99);
    }

    #[test]
    fn handling_handles() {
        let (mut client, _) = enqueued_client(100);

        assert_eq!(200, client.handle(100, 100));
        assert_eq!(&Status::Answered, client.status());
        assert_eq!(Some(0), client.wait_time());
    }

    #[should_panic]
    #[test]
    fn handle_only_when_enqueued() {
        let mut client = Client::default();
        client.set_start(100);

        assert_eq!(&Status::Pending, client.status());

        client.handle(120, 1);
    }

    #[should_panic]
    #[test]
    fn handling_only_works_in_future() {
        let (mut client, _) = enqueued_client(100);

        client.handle(99, 1);
    }

    #[test]
    fn wait_time_abandoned() {
        let (mut client, abandon_tick) = enqueued_client(100);
        client.tick_wait(abandon_tick);

        assert_eq!(&Status::Abandoned, client.status());
        assert_eq!(Some(abandon_tick - 100), client.wait_time());
    }

    #[test]
    fn wait_time_answered() {
        let (mut client, _) = enqueued_client(100);
        client.handle(200, 1);

        assert_eq!(&Status::Answered, client.status());
        assert_eq!(Some(100), client.wait_time());
    }

    #[test]
    fn wait_time_unanswered() {
        let (mut client, _) = enqueued_client(100);
        client.tick_wait(101);

        assert_eq!(&Status::Enqueued, client.status());
        assert_eq!(None, client.wait_time());
    }

    #[test]
    fn handle_time_unanswered() {
        let (mut client, _) = enqueued_client(100);
        client.tick_wait(101);

        assert_eq!(&Status::Enqueued, client.status());
        assert_eq!(None, client.handle_time());
    }

    #[test]
    fn handle_time_answered() {
        let (mut client, _) = enqueued_client(100);
        client.handle(200, 100);

        assert_eq!(&Status::Answered, client.status());
        assert_eq!(Some(100), client.handle_time());
    }

    #[test]
    fn handle_time_abandonend() {
        let (mut client, abandon_tick) = enqueued_client(100);
        client.tick_wait(abandon_tick);

        assert_eq!(&Status::Abandoned, client.status());
        assert_eq!(None, client.handle_time());
    }
}
